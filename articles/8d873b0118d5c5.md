---
title: "紙を編んで曲面を作ろう！ [ElasticSurfaceEmbedding.jlの紹介]"
emoji: "🏳️‍🌈"
type: "tech"
topics:
  - "julia"
  - "math"
  - "数値計算"
  - "紙工作"
published: false
---

# はじめに
先月、[はじめての論文](https://arxiv.org/abs/2211.06372)をarXivで公開しました！
紙を編んで曲面をつくる研究で、理論的な解説は[連ツイ](https://twitter.com/Hyrodium/status/1592133224876363776)にあります。

![](https://github.com/hyrodium/ElasticSurfaceEmbedding.jl/raw/main/docs/src/img/CatenoidHelicoid.gif)

製作中の様子↓
![](https://storage.googleapis.com/zenn-user-upload/1689f7637276-20221129.png)

本記事では、この理論をJuliaで実装した[ElasticSurfaceEmbedding.jl](https://github.com/hyrodium/ElasticSurfaceEmbedding.jl)の解説をします！

# インストール方法
Juliaのpkgモードで以下を実行してください。
```
(@v1.8) pkg> add BasicBSpline StaticArrays IntervalSets
(@v1.8) pkg> add https://github.com/hyrodium/BasicBSplineExporter.jl
(@v1.8) pkg> add https://github.com/hyrodium/ElasticSurfaceEmbedding.jl
```

# 最初の実行例: 放物面
https://twitter.com/Hyrodium/status/1067772101333929987

この曲面は以下の画像のようにして作っています。
![](https://storage.googleapis.com/zenn-user-upload/fbab08ee29f2-20221129.png)

左から順に以下を表しています。

1. 曲面の形状の定義
2. 曲面を長細い曲面片に分割
3. それぞれの曲面片の切り出し形状の計算
4. 平面材料(紙)から切り出し
5. 編んで完成！

この一連の流れにおいて **3の「切り出し形状の計算」** が一番非自明で、この形状を計算するパッケージが前述の[ElasticSurfaceEmbedding.jl](https://github.com/hyrodium/ElasticSurfaceEmbedding.jl)です。あとで少し詳しく説明しますが、この形状は「弾性エネルギーを最小にする2次元Euclid空間への埋め込み」として特徴づけられています。"ElasticSurfaceEmbedding"の名前にはこの意味が込められています。

放物面を編むための形状を計算するには以下を実行します。(REPLにコピペすればOK)
```julia
using IntervalSets
using BasicBSpline
using StaticArrays
using ElasticSurfaceEmbedding
ElasticSurfaceEmbedding.𝒑₍₀₎(u¹,u²) = SVector(u¹, u², u¹^2+u²^2)
n = 10
D(i,n) = (-1.0..1.0, (i-1)/n..i/n)
allsteps = AllSteps()
for i in 1:10
    initial_state!(allsteps, D(i,n), n₁=25)
    newton_onestep!(allsteps, fixingmethod=:fix3points)
    newton_onestep!(allsteps)
    refinement!(allsteps, p₊=(0,1), k₊=(EmptyKnotVector(),KnotVector([(i-1/2)/10])))
    newton_onestep!(allsteps)
    newton_onestep!(allsteps)
    pin!(allsteps)
end
export_pinned_steps(".", allsteps, unitlength=(50, "mm"), mesh=(20,1))
```
処理内容の解説は後述するとして、実行結果は`allsteps`の出力から確認できます。
:::details `allsteps`の出力
```julia
julia> allsteps
1: Initial state - domain: [-1.0, 1.0]×[0.0, 0.1]
└─2: Newton onestep - residual norm: 3.0098e-02, Δa norm: 1.9847e-02, computation time: 22ms
  └─3: Newton onestep - residual norm: 1.8804e-03, Δa norm: 1.3264e-02, computation time: 22ms
    └─4: Refinement - p₊:(0, 1), k₊:(Bool[], [0.05])
      └─5: Newton onestep - residual norm: 1.8434e-03, Δa norm: 4.3219e-03, computation time: 77ms
        └─6: 📌 Newton onestep - residual norm: 2.7186e-06, Δa norm: 1.3806e-04, computation time: 99ms
7: Initial state - domain: [-1.0, 1.0]×[0.1, 0.2]
└─8: Newton onestep - residual norm: 3.3025e-02, Δa norm: 2.3630e-02, computation time: 31ms
  └─9: Newton onestep - residual norm: 1.9982e-03, Δa norm: 1.4734e-02, computation time: 25ms
    └─10: Refinement - p₊:(0, 1), k₊:(Bool[], [0.15])
      └─11: Newton onestep - residual norm: 1.6288e-03, Δa norm: 1.0403e-02, computation time: 81ms
        └─12: 📌 Newton onestep - residual norm: 3.9412e-06, Δa norm: 3.1503e-04, computation time: 82ms
13: Initial state - domain: [-1.0, 1.0]×[0.2, 0.3]
└─14: Newton onestep - residual norm: 3.6870e-02, Δa norm: 2.6618e-02, computation time: 24ms
  └─15: Newton onestep - residual norm: 2.1813e-03, Δa norm: 1.3912e-02, computation time: 24ms
    └─16: Refinement - p₊:(0, 1), k₊:(Bool[], [0.25])
      └─17: Newton onestep - residual norm: 1.3023e-03, Δa norm: 1.2485e-02, computation time: 83ms
        └─18: 📌 Newton onestep - residual norm: 4.4132e-06, Δa norm: 3.3974e-04, computation time: 82ms
19: Initial state - domain: [-1.0, 1.0]×[0.3, 0.4]
└─20: Newton onestep - residual norm: 4.0001e-02, Δa norm: 2.8676e-02, computation time: 24ms
  └─21: Newton onestep - residual norm: 2.3386e-03, Δa norm: 1.2158e-02, computation time: 23ms
    └─22: Refinement - p₊:(0, 1), k₊:(Bool[], [0.35])
      └─23: Newton onestep - residual norm: 9.7245e-04, Δa norm: 1.2222e-02, computation time: 83ms
        └─24: 📌 Newton onestep - residual norm: 3.9234e-06, Δa norm: 2.7297e-04, computation time: 83ms
25: Initial state - domain: [-1.0, 1.0]×[0.4, 0.5]
└─26: Newton onestep - residual norm: 4.1891e-02, Δa norm: 3.0282e-02, computation time: 23ms
  └─27: Newton onestep - residual norm: 2.4125e-03, Δa norm: 1.0475e-02, computation time: 23ms
    └─28: Refinement - p₊:(0, 1), k₊:(Bool[], [0.45])
      └─29: Newton onestep - residual norm: 6.9762e-04, Δa norm: 1.0958e-02, computation time: 83ms
        └─30: 📌 Newton onestep - residual norm: 3.1803e-06, Δa norm: 1.8120e-04, computation time: 82ms
31: Initial state - domain: [-1.0, 1.0]×[0.5, 0.6]
└─32: Newton onestep - residual norm: 4.2636e-02, Δa norm: 3.1610e-02, computation time: 24ms
  └─33: Newton onestep - residual norm: 2.4006e-03, Δa norm: 9.0638e-03, computation time: 23ms
    └─34: Refinement - p₊:(0, 1), k₊:(Bool[], [0.55])
      └─35: Newton onestep - residual norm: 4.9253e-04, Δa norm: 9.3891e-03, computation time: 81ms
        └─36: 📌 Newton onestep - residual norm: 2.4826e-06, Δa norm: 1.0638e-04, computation time: 82ms
37: Initial state - domain: [-1.0, 1.0]×[0.6, 0.7]
└─38: Newton onestep - residual norm: 4.2520e-02, Δa norm: 3.2710e-02, computation time: 23ms
  └─39: Newton onestep - residual norm: 2.3252e-03, Δa norm: 7.9393e-03, computation time: 23ms
    └─40: Refinement - p₊:(0, 1), k₊:(Bool[], [0.65])
      └─41: Newton onestep - residual norm: 3.5192e-04, Δa norm: 7.8423e-03, computation time: 85ms
        └─42: 📌 Newton onestep - residual norm: 1.8940e-06, Δa norm: 5.9199e-05, computation time: 83ms
43: Initial state - domain: [-1.0, 1.0]×[0.7, 0.8]
└─44: Newton onestep - residual norm: 4.1818e-02, Δa norm: 3.3595e-02, computation time: 24ms
  └─45: Newton onestep - residual norm: 2.2113e-03, Δa norm: 7.0824e-03, computation time: 24ms
    └─46: Refinement - p₊:(0, 1), k₊:(Bool[], [0.75])
      └─47: Newton onestep - residual norm: 2.6462e-04, Δa norm: 6.4460e-03, computation time: 84ms
        └─48: 📌 Newton onestep - residual norm: 1.4061e-06, Δa norm: 3.3403e-05, computation time: 87ms
49: Initial state - domain: [-1.0, 1.0]×[0.8, 0.9]
└─50: Newton onestep - residual norm: 4.0747e-02, Δa norm: 3.4278e-02, computation time: 23ms
  └─51: Newton onestep - residual norm: 2.0776e-03, Δa norm: 6.4475e-03, computation time: 23ms
    └─52: Refinement - p₊:(0, 1), k₊:(Bool[], [0.85])
      └─53: Newton onestep - residual norm: 2.1727e-04, Δa norm: 5.2313e-03, computation time: 83ms
        └─54: 📌 Newton onestep - residual norm: 1.0064e-06, Δa norm: 1.9814e-05, computation time: 83ms
55: Initial state - domain: [-1.0, 1.0]×[0.9, 1.0]
└─56: Newton onestep - residual norm: 3.9462e-02, Δa norm: 3.4782e-02, computation time: 24ms
  └─57: Newton onestep - residual norm: 1.9369e-03, Δa norm: 5.9769e-03, computation time: 23ms
    └─58: Refinement - p₊:(0, 1), k₊:(Bool[], [0.95])
      └─59: Newton onestep - residual norm: 1.9491e-04, Δa norm: 4.1940e-03, computation time: 84ms
        └─60: 📌 Newton onestep - residual norm: 6.8995e-07, Δa norm: 1.2158e-05, computation time: 83ms
```
:::

実行結果は`./pinned`以下にSVG画像として出力されます。
```
.
└── pinned
    ├── pinned-6.svg
    ├── pinned-12.svg
    ├── pinned-18.svg
    ├── pinned-24.svg
    ├── pinned-30.svg
    ├── pinned-36.svg
    ├── pinned-42.svg
    ├── pinned-48.svg
    ├── pinned-54.svg
    └── pinned-60.svg
```
`pinned-6.svg`の例:

<画像>

この形状[^1]をレーザー加工機で切り出し、編み上げれば放物面が完成します！

[^1]: この埋め込み形状は[論文](https://arxiv.org/abs/2211.06372)のAppendix Bにも記載されています。

![](https://storage.googleapis.com/zenn-user-upload/ec7bc5d2199f-20221129.png)

# コードの解説
前節では天下り的にコードを提示していました。本節ではそれの解説をします。

```julia
using IntervalSets
using BasicBSpline
using StaticArrays
using ElasticSurfaceEmbedding
```
まずはパッケージの読み込みですね。
[BasicBSpline.jl](https://github.com/hyrodium/BasicBSpline.jl)は[以前の記事](https://zenn.dev/hyrodium/articles/5fb08f98d4a918)でも紹介したパッケージですが、元々は本研究のために書いたコードがベースになっています。
<!-- 別の記事であらためて紹介予定です。 -->

```julia
ElasticSurfaceEmbedding.𝒑₍₀₎(u¹,u²) = SVector(u¹, u², u¹^2+u²^2)
```
は曲面の形状を定義です。少し気持ち悪いですが、メソッドの上書きが必要になります。[^2]
[^2]: 引数に関数を入れるように実装したことがありましたが、実行速度の低下があったので断念しました。詳細な速度低下の原因は未調査で、今後時間があれば修正される可能性があります。ただ、複数の形状を同時に計算しないはずなので、メソッドの上書きでも大きな問題にはなりません。

```julia
n = 10
D(i,n) = (-1.0..1.0, (i-1)/n..i/n)
```
こちらは定義域の定義ですね。

```julia
allsteps = AllSteps()
```
計算結果を木構造で持つためのインスタンスを定義します。

```julia
for i in 1:10
    initial_state!(allsteps, D(i,n), n₁=25)
    newton_onestep!(allsteps, fixingmethod=:fix3points)
    newton_onestep!(allsteps)
    refinement!(allsteps, p₊=(0,1), k₊=(EmptyKnotVector(),KnotVector([(i-1/2)/10])))
    newton_onestep!(allsteps)
    newton_onestep!(allsteps)
    pin!(allsteps)
end
```
ここがメインの処理で、以下のステップを繰り返す処理になります。

* 初期値決定(`initial_state!`)
    * `i`を回して定義域を$[-1,1]\times[0.0,0.1]$から$[-1,1]\times[0.9,1.0]$まで計算。
    * 測地的曲率をもとに初期形状を決定する。
* Newton法(`newton_onestep!`)
    * Newton法で計算しているので収束は早い。
    収束の自動判定は未実装(数回決め打ちで十分)。
* Refinement(`refinement!`)
    * 制御点を増やして数値解の精度向上を図る方法。

SVG出力するステップを`pin!(allsteps)`で指定しています。

# 内部処理の解説
## 歪エネルギー最小化[^3]
[^3]: hoge

## B-splineについて


## 途中の計算結果


## 制御点の固定


