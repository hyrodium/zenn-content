---
title: "新しくなったBasicBSpline.jl(v0.8.3)の紹介"
emoji: "💫"
type: "tech"
topics:
  - "julia"
  - "math"
published: false
---

# はじめに
一昨年に[BasicBSpline.jlを作ったので宣伝です！](https://zenn.dev/hyrodium/articles/5fb08f98d4a918)を書きました。
当時はBasicBSpline.jlの`v0.1.1`をリリースしたばかりでしたが、現在のBasicBSpline.jlの最新バージョンは`v0.8.3`です。
主な変更点は以下です。

* ノット列の型`KnotVector`がパラメトリック型になって`Float64`以外にも`Rational`や`BigFloat`に対応できるようになった
* NURBSに対応した
* Plots.jlに対応した
* 標準の`BSplineSpace`のみで高速かつ汎用になった
* 等間隔ノット列の型(`UniformKnotVector`)を用意して、一部の演算が高速化された
* 関数・型の名称変更 (e.g. `Knots`→`KnotVector`, `bsplineunity`→`domain`)

以前の記事は古くなってしまったので、本記事では新しくなったBasicBSpline.jlでのコード例や実装時に気をつけたことなどを書いていこうと思います。

# B-splineってなに？
区分多項式を便利に扱えるように、関数空間の基底を取りやすいように道具を整備したものがB-splineです。
これまでに、色々なB-splineの資料を作ってきました。

* [B-spline入門（線形代数がすこし分かる人向け）](https://www.youtube.com/watch?v=GOdY02PA_WI)
    * 動画で学びたい人はこちら。
    * 数理的なモチベーションが伝わりやすい…はず
* [NURBS多様体による形状表現](https://hyrodium.github.io/ja/pdf/#NURBS%E5%A4%9A%E6%A7%98%E4%BD%93%E3%81%AB%E3%82%88%E3%82%8B%E5%BD%A2%E7%8A%B6%E8%A1%A8%E7%8F%BE)
    * 証明を詳細にフォローしたい人はこちら。
* [BasicBSpline.jlのドキュメント](https://hyrodium.github.io/BasicBSpline.jl/stable/)
    * Juliaで実行しながらB-splineを勉強したい人はこちら。
    * 英語で書いてます。
* [BasicBSpline.jlを作ったので宣伝です！](https://zenn.dev/hyrodium/articles/5fb08f98d4a918)
    * 前述の記事でBasicBSpline.jlの説明としては古いですが、B-splineのモチベーションの説明としては悪くないと思います。

私の作ったものとは違いますが、数日前に投稿された次の動画が視覚的に綺麗に可視化されていてかなり良かったです。

https://www.youtube.com/watch?v=jvPPXbo87ds

書籍では以下がオススメです。

* [geo]


# BasicBSpline.jlのつかいかた
B-spline自体のモチベーションは既に上記資料で説明したので、以下ではコード例を紹介します。

## 形状表現
B-splineの応用として最も有用なものの一つが形状表現です。
[以前の記事](https://zenn.dev/hyrodium/articles/5fb08f98d4a918)でも説明した通り、B-spline多様体はBézier曲線を一般化したものです。
その形状は矩形領域からAffine空間への区分多項式の像として定義されます。

トーラスの例

## 内挿補間
区分多項式による補間にもB-splineを使うことができます。
B-spline

## 関数フィッティング
関数にフィッティングする

# BasicBSpline.jlの内部実装
以降の本記事では、BasicBSpline.jlの実装においてJuliaの言語機能がどのように便利だったかをお伝えします！
かなり雑多な内容になりますが、Juliaの便利さ・面白さを少しでもお伝えできれば嬉しいです。

## ノット列
実軸上に乗った広義単調増大の有限列が、ノット列と呼ばれるものです。
B-splineは区分多項式を扱う道具で、ノットに囲まれた各区間が一つの多項式に対応します。

「絵」

### 抽象型と型変換
Juliaの型は木構造[^tree]になっており、根は`Any`です。
BasicBSplineにおけるノット列を表す抽象型が`AbstractKnotVector`で、以下のような部分型を持ちます。

```julia
julia> subtypes(AbstractKnotVector)
3-element Vector{Any}:
 EmptyKnotVector{T} where T<:Real
 KnotVector{T} where T<:Real
 UniformKnotVector{T} where T<:Real
```

[^tree]: 子を持つ型が抽象型(e.g. `Real`)と呼ばれ、子を持たない型が具象型(e.g. `Float64`)です。

これらのノット列は以下のようにインスタンスを定義できます。
```julia
julia> k1 = KnotVector([1, 4, 2.])  # コンストラクタが引数をsortする
KnotVector([1.0, 2.0, 4.0])

julia> k2 = KnotVector(1:5)
KnotVector([1, 2, 3, 4, 5])

julia> k3 = UniformKnotVector(1:5)  # 等間隔なノット列を扱うための型
UniformKnotVector(1:5)

julia> k4 = EmptyKnotVector()  # 空のノット列を扱うための型
EmptyKnotVector{Bool}()

julia> k5 = KnotVector(Float64[])
KnotVector(Float64[])
```

異なる型どうしでも等号比較できます。
```julia
julia> k1 == k2  # KnotVector{Float64}とKnotVector{Int}
false

julia> k2 == k3  # KnotVector{Int}とUniformKnotVector
true

julia> k4 == k5  # EmptyKnotVectorとKnotVector
true
```

型変換も実装されています。
```julia
julia> convert(KnotVector{Int}, k3)
KnotVector([1, 2, 3, 4, 5])

julia> KnotVector(k3)  # convertとほぼ同じ
KnotVector([1, 2, 3, 4, 5])

julia> KnotVector(k4)
KnotVector(Bool[])

julia> convert(UniformKnotVector{Int}, k2)  # k2が等間隔だとしてもUniformKnotVectorへは変換できない
ERROR: MethodError: no method matching (UniformKnotVector{Int64})(::KnotVector{Int64})
```

:::message
相互に変換できる型を同じ抽象型に入れると便利。型の包含関係は、数学的な集合としての包含関係とは異なることに注意。
:::

### 効率的なコンストラクタ
`KnotVector{T}`型はノット列を内部的に`Vector{T}`として保持していますが、標準的なコンストラクタでは引数がコピー・ソートされるようになっています。
```julia
julia> v1 = [2,4,3]
3-element Vector{Int64}:
 2
 4
 3

julia> k1 = KnotVector(v1)
KnotVector([2, 3, 4])

julia> v1[1] = 3  # v1の要素を書き換えても
3

julia> k1  # k1は変わらない
KnotVector([2, 3, 4])
```

しかし以下ケースではデフォルトの`KnotVector`のコンストラクタには不満があります。

* パフォーマンスのために配列のコピーを避けたい
* 引数の配列がソートされている場合にデフォルトのソートを避けたい

このようなケースに対応するため、`unsafe_knotvector`関数が用意されています。
```julia
julia> v2 = [2,4,3]
3-element Vector{Int64}:
 2
 4
 3

julia> k2 = BasicBSpline.unsafe_knotvector(Int, v2)  # sortしない
KnotVector([2, 4, 3])

julia> v2[1] = 5  # v2の値を書き換えると
5

julia> k2
KnotVector([5, 4, 3])  # k2も変わる。メモリを共有しているため
```
`KnotVector`のインスタンスを生成するには`KnotVector`のコンストラクタを経由する必要があるので、デフォルトの`KnotVector`コンストラクタの処理を避けるのは困難なように思えます。
このような動作を実現するには、`KnotVector`の`struct`の内側に`global`つきで関数を定義することで[実装できます](https://github.com/hyrodium/BasicBSpline.jl/blob/v0.8.3/src/_KnotVector.jl#L20-L23)。
```julia
struct KnotVector{T} <: AbstractKnotVector{T}
    vector::Vector{T}
    global unsafe_knotvector(::Type{T}, v) where T = new{T}(v)
end
```
`Base.Rational`に対しても同様の`unsafe_rational`が用意されており、同じような`struct`の内側に`global`が入るように実装されています。
```julia
julia> Rational(2,4)
1//2

julia> Base.unsafe_rational(2,4)
2//4
```

:::message
デフォルトのコンストラクタを避けれるような実装にするには、`struct`の内側に`global`つきでコンストラクタを定義すれば良い。
:::


### 加法
BasicBSpline.jlでは、以下のようにノット列(`KnotVector`)の足し算(`+`)ができます。[^addition]

```julia
julia> k1 = KnotVector([1, 2, 3])
KnotVector([1, 2, 3])

julia> k2 = KnotVector([2, 4.5])
KnotVector([2.0, 4.5])

julia> k1+k2
KnotVector([1.0, 2.0, 2.0, 3.0, 4.5])

julia> typeof(k1), typeof(k2)
(KnotVector{Int64}, KnotVector{Float64})
```

この`+`の操作は`Base.:+`関数に`KnotVector`用のメソッドを追加して実装されています。
Juliaの多重ディスパッチの仕組みがここで便利です。

[^addition]: この「ノット列を足す操作」は可換なので、`+`の記号を採用しました。文字列の結合は非可換なのでJuliaでは`*`が使われます。`∪`を避けたのは重複した要素を保持することを強調したかったためです。

:::message
`Number`の部分型でなくとも、加法っぽい可換な二項演算に対しては`Base.:+`にメソッドを追加して良い。
:::

### 型の昇格 (type promotion)
型の異なる足し算については、type promotionの仕組み[^promotion]によって同じ型に揃えられてから足し算が実行されます。
上記の例では、`k1`が`KnotVector{Float64}`に変換されてから足し算が実行されます。

[^promotion]: 暗黙の型変換に近いですが、型変換が言語にハードコーディングされている訳ではなく、ユーザーが自由に設定することができます。

BasicBSplineでは以下のように`promote_rule`にメソッドを追加することで[明示的に型変換を定義しています](https://github.com/hyrodium/BasicBSpline.jl/blob/v0.8.3/src/_KnotVector.jl#L36-L38)。[^promotion2]

```julia
function Base.promote_rule(::Type{KnotVector{T}}, ::Type{KnotVector{S}}) where {T,S}
    KnotVector{promote_type(T,S)}
end
```

[^promotion2]: このpromotionの仕組みの便利なところは、型Aと型Bの昇格のルールを決めるだけで、AとBを使ったメソッドすべてに型変換が利用できることにあります。
例えば、`A`と`B`が両方とも`Real`の部分型であれば、`+(::A, ::B)`, `-(::A, ::B)`, `*(::A, ::B)`, `/(::A, ::B)`などのすべてに定義が使えます。

## B-spline空間 (区分多項式空間)
ノット列を区分点に持つ$p$次区分多項式全体の空間を$p$次B-spline空間と呼びます。[^bspspace]
この空間は線形空間で、空間の次元や空間どうしの包含関係などが定義できます。

[^bspspace]: 独自用語です。広く普及している名称では無いことに注意してください。B-spline基底関数が基底になっています。

### 多項式次数と型パラメータ
BasicBSplineでは、B-spline空間を表す抽象型として`AbstractBSplineSpace{p}`が用意されています。
ここで`p`は多項式次数を表す型パラメータで、構造体のフィールドに含まれる実装にはなっていません。
このような型パラメータを使った理由は以下になります。

* ほとんどの場合で多項式次数は実行時に変わることはないので型パラメータを使って問題ない。
* 後述の生成関数(`@generated`)を使うことで高速な実装が実現できる。

:::message
`struct`のフィールドにするか、型パラメータにするかは

* 型パラメータにした際に速度向上が望めるか
* 実行時に型安定性を望めるか

を基準に考えれば良い。
:::

### 生成関数を使った実装


### プロット


:::message
独自に定義した型の標準的なプロットを追加するには、`RecipesBase.@recipe`でプロットを定義できる
:::


### 包含関係
メソッドの追加の話



## 


# Q&A
## いつv1.0を出すんですか？

## 他のパッケージよりも優れてるんですか？
なにも分からない…。


* Unicode文字による数学表記が便利！
* 型の昇格(type promotion)が便利！
* 生成関数(generated function)による一般の多項式次数への対応
