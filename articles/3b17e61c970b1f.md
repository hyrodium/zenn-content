---
title: "新しくなったBasicBSpline.jl(v0.8.3)の紹介"
emoji: "💫"
type: "tech"
topics:
  - "julia"
  - "math"
published: false
---

# はじめに
一昨年に[BasicBSpline.jlを作ったので宣伝です！](https://zenn.dev/hyrodium/articles/5fb08f98d4a918)を書きました。
当時はBasicBSpline.jlの`v0.1.1`をリリースしたばかりでしたが、現在のBasicBSpline.jlの最新バージョンは`v0.8.3`です。
主な変更点は以下です。

* ノット列の型`KnotVector`がパラメトリック型になって`Float64`以外にも`Rational`や`BigFloat`に対応できるようになった
* NURBSに対応した
* Plots.jlに対応した
* 標準の`BSplineSpace`のみで高速かつ汎用になった
* 等間隔ノット列の型(`UniformKnotVector`)を用意して、一部の演算が高速化された
* 関数・型の名称変更 (e.g. `Knots`→`KnotVector`, `bsplineunity`→`domain`)

以前の記事は古くなってしまったので、本記事では新しくなったBasicBSpline.jlでのコード例や実装時に気をつけたことなどを書いていこうと思います。

# B-splineってなに？
区分多項式を便利に扱えるように、関数空間の基底を取りやすいように道具を整備したものがB-splineです。
これまでに、色々なB-splineの資料を作ってきました。

* [B-spline入門（線形代数がすこし分かる人向け）](https://www.youtube.com/watch?v=GOdY02PA_WI)
    * 動画で学びたい人はこちら。
    * 数理的なモチベーションが伝わりやすい…はず
* [NURBS多様体による形状表現](https://hyrodium.github.io/ja/pdf/#NURBS%E5%A4%9A%E6%A7%98%E4%BD%93%E3%81%AB%E3%82%88%E3%82%8B%E5%BD%A2%E7%8A%B6%E8%A1%A8%E7%8F%BE)
    * 証明を詳細にフォローしたい人はこちら。
* [BasicBSpline.jlのドキュメント](https://hyrodium.github.io/BasicBSpline.jl/stable/)
    * Juliaで実行しながらB-splineを勉強したい人はこちら。
    * 英語で書いてます。
* [BasicBSpline.jlを作ったので宣伝です！](https://zenn.dev/hyrodium/articles/5fb08f98d4a918)
    * 前述の記事でBasicBSpline.jlの説明としては古いですが、B-splineのモチベーションの説明としては悪くないと思います。

私の作ったものとは違いますが、数日前に投稿された次の動画が視覚的に綺麗に可視化されていてかなり良かったです。

https://www.youtube.com/watch?v=jvPPXbo87ds

書籍では以下がオススメです。

* [geo]


# BasicBSpline.jlのつかいかた
B-spline自体のモチベーションは既に上記資料で説明したので、以下ではコード例を紹介します。

## 形状表現
B-splineを使えば、ノット列と制御点と重みを使って形状を定義することができます。
たとえばトーラスは以下のようになります。

```julia
using BasicBSpline
using StaticArrays
using Plots
plotly()

# 半径の定義
R = 3
r = 1

# 制御点の定義
a0 = [
    SVector( 1, 0, 0),
    SVector( 1, 1, 0),
    SVector( 0, 1, 0),
    SVector(-1, 1, 0),
    SVector(-1, 0, 0),
    SVector(-1,-1, 0),
    SVector( 0,-1, 0),
    SVector( 1,-1, 0),
    SVector( 1, 0, 0)
]
a1 = (R+r)*a0
a5 = (R-r)*a0
a2 = [p+r*SVector(0,0,1) for p in a1]
a3 = [p+r*SVector(0,0,1) for p in R*a0]
a4 = [p+r*SVector(0,0,1) for p in a5]
a6 = [p-r*SVector(0,0,1) for p in a5]
a7 = [p-r*SVector(0,0,1) for p in R*a0]
a8 = [p-r*SVector(0,0,1) for p in a1]
a9 = a1
a = hcat(a1,a2,a3,a4,a5,a6,a7,a8,a9)

# 重みの定義
w = [1,1/√2,1,1/√2,1,1/√2,1,1/√2,1]

# B-spline空間の定義
k = KnotVector([0,0,0,1,1,2,2,3,3,4,4,4])
P = BSplineSpace{2}(k)

# B-spline多様体の定義
M = RationalBSplineManifold(a, w*w', P, P)
plot(M)
```

![](/images/3b17e61c970b1f/torus.png)
![](https://storage.googleapis.com/zenn-user-upload/8fdcc43a3944-20221225.png)

## 内挿補間
区分多項式による補間にもB-splineを使うことができます。
```julia
using BasicBSpline
using StaticArrays
using Plots

function interpolate(xs::AbstractVector, fs::AbstractVector{T}) where T
    # Cubic open B-spline space
    p = 3
    k = KnotVector(xs) + KnotVector([xs[1],xs[end]]) * p
    P = BSplineSpace{p}(k)

    # dimensions
    m = length(xs)
    n = dim(P)

    # The interpolant function has a f''=0 property at bounds.
    ddP = BSplineDerivativeSpace{2}(P)
    dda = [bsplinebasis(ddP,j,xs[1]) for j in 1:n]
    ddb = [bsplinebasis(ddP,j,xs[m]) for j in 1:n]

    # Compute the interpolant function (1-dim B-spline manifold)
    M = [bsplinebasis(P,j,xs[i]) for i in 1:m, j in 1:n]
    M = vcat(dda', M, ddb')
    y = vcat(zero(T), fs, zero(T))
    return BSplineManifold(M\y, P)
end

# Example inputs
xs = [1, 2, 3, 4, 6, 7]
fs = [1.3, 1.5, 2, 2.1, 1.9, 1.3]
f = interpolate(xs,fs)

# Plot
scatter(xs, fs)
plot!(t->f(t))
```

![](/images/3b17e61c970b1f/interpolation.png)
![](https://storage.googleapis.com/zenn-user-upload/82830cce949a-20221225.png)

## 関数フィッティング
関数にフィッティングする

```julia
using BasicBSpline
using StaticArrays
using Plots

f(t) = SVector(t,sin(t)) # 正弦波のパラメータ表示
t0,t1 = -6,6             # 左端と右端

p = 3
k = KnotVector(t0:t1)+p*KnotVector([t0,t1])
P = BSplineSpace{p}(k)

a = fittingcontrolpoints(f,P)  # B-spline曲線の制御点の計算
M = BSplineManifold(a,P)
plot(sin,-10,10)
plot!(M)
```

![](/images/3b17e61c970b1f/sin-fitting.png)
![](https://storage.googleapis.com/zenn-user-upload/9b8087d73339-20221225.png)

[なめらかな曲線をJuliaでSVG出力する](https://zenn.dev/hyrodium/articles/9e7ce1b67afc57)もどうぞ！

# BasicBSpline.jlの内部実装
以降の本記事では、BasicBSpline.jlの実装においてJuliaの言語機能がどのように便利だったかをお伝えします！
かなり雑多な内容になりますが、Juliaの便利さ・面白さを少しでもお伝えできれば嬉しいです。

## ノット列
実軸上に乗った広義単調増大の有限列が、ノット列と呼ばれるものです。
B-splineは区分多項式を扱う道具で、ノットに囲まれた各区間が一つの多項式に対応します。

「絵」

### 抽象型と型変換
Juliaの型は木構造[^tree]になっており、根は`Any`です。
BasicBSplineにおけるノット列を表す抽象型が`AbstractKnotVector`で、以下のような部分型を持ちます。

```julia
julia> subtypes(AbstractKnotVector)
3-element Vector{Any}:
 EmptyKnotVector{T} where T<:Real
 KnotVector{T} where T<:Real
 UniformKnotVector{T} where T<:Real
```

[^tree]: 子を持つ型が抽象型(e.g. `Real`)で、子を持てない型が具象型(e.g. `Float64`)です。

これらのノット列は以下のようにインスタンスを定義できます。
```julia
julia> k1 = KnotVector([1, 4, 2.])  # コンストラクタが引数をsortする
KnotVector([1.0, 2.0, 4.0])

julia> k2 = KnotVector(1:5)
KnotVector([1, 2, 3, 4, 5])

julia> k3 = UniformKnotVector(1:5)  # 等間隔なノット列を扱うための型
UniformKnotVector(1:5)

julia> k4 = EmptyKnotVector()  # 空のノット列を扱うための型
EmptyKnotVector{Bool}()

julia> k5 = KnotVector(Float64[])
KnotVector(Float64[])
```

異なる型どうしでも等号比較できます。
```julia
julia> k1 == k2  # KnotVector{Float64}とKnotVector{Int}
false

julia> k2 == k3  # KnotVector{Int}とUniformKnotVector
true

julia> k4 == k5  # EmptyKnotVectorとKnotVector
true
```

型変換も実装されています。
```julia
julia> convert(KnotVector{Int}, k3)
KnotVector([1, 2, 3, 4, 5])

julia> KnotVector(k3)  # convertとほぼ同じ
KnotVector([1, 2, 3, 4, 5])

julia> KnotVector(k4)
KnotVector(Bool[])

julia> convert(UniformKnotVector{Int}, k2)  # k2が等間隔だとしてもUniformKnotVectorへは変換できない
ERROR: MethodError: no method matching (UniformKnotVector{Int64})(::KnotVector{Int64})
```

:::message
相互に変換できる型を同じ抽象型に入れると便利。型の包含関係は、数学的な集合としての包含関係とは異なることに注意。
:::

### 効率的なコンストラクタ
`KnotVector{T}`型はノット列を内部的に`Vector{T}`として保持していますが、標準的なコンストラクタでは引数がコピー・ソートされるようになっています。
```julia
julia> v1 = [2,4,3]
3-element Vector{Int64}:
 2
 4
 3

julia> k1 = KnotVector(v1)
KnotVector([2, 3, 4])

julia> v1[1] = 3  # v1の要素を書き換えても
3

julia> k1  # k1は変わらない
KnotVector([2, 3, 4])
```

しかし以下ケースではデフォルトの`KnotVector`のコンストラクタには不満があります。

* パフォーマンスのために配列のコピーを避けたい
* 引数の配列がソートされている場合にデフォルトのソートを避けたい

このようなケースに対応するため、`unsafe_knotvector`関数が用意されています。
```julia
julia> v2 = [2,4,3]
3-element Vector{Int64}:
 2
 4
 3

julia> k2 = BasicBSpline.unsafe_knotvector(Int, v2)  # sortしない
KnotVector([2, 4, 3])

julia> v2[1] = 5  # v2の値を書き換えると…
5

julia> k2
KnotVector([5, 4, 3])  # k2も変わる。メモリを共有しているため
```
`KnotVector`のインスタンスを生成するには`KnotVector`のコンストラクタを経由する必要があるので、デフォルトの`KnotVector`コンストラクタの処理を避けるのは困難なように思えます。
このような動作を実現するには、`KnotVector`の`struct`の内側に`global`つきで関数を定義することで[実装できます](https://github.com/hyrodium/BasicBSpline.jl/blob/v0.8.3/src/_KnotVector.jl#L20-L23)。
```julia
struct KnotVector{T} <: AbstractKnotVector{T}
    vector::Vector{T}
    global unsafe_knotvector(::Type{T}, v) where T = new{T}(v)
end
```
`Base.Rational`に対しても同様の`unsafe_rational`が用意されており、同じような`struct`の内側に`global`が入るように実装されています。
```julia
julia> Rational(2,4)
1//2

julia> Base.unsafe_rational(2,4)
2//4
```

:::message
デフォルトのコンストラクタを避けれるような実装にするには、`struct`の内側に`global`つきでコンストラクタを定義すれば良い。
:::


### 加法
BasicBSpline.jlでは、以下のようにノット列(`KnotVector`)の足し算(`+`)ができます。[^addition]

```julia
julia> k1 = KnotVector([1, 2, 3])
KnotVector([1, 2, 3])

julia> k2 = KnotVector([2, 4.5])
KnotVector([2.0, 4.5])

julia> k1+k2
KnotVector([1.0, 2.0, 2.0, 3.0, 4.5])

julia> typeof(k1), typeof(k2)
(KnotVector{Int64}, KnotVector{Float64})
```

この`+`の操作は`Base.:+`関数に`KnotVector`用のメソッドを追加して実装されています。
Juliaの多重ディスパッチの仕組みがここで便利です。

[^addition]: この「ノット列を足す操作」は可換なので、`+`の記号を採用しました。文字列の結合は非可換なのでJuliaでは`*`が使われます。`∪`を避けたのは重複した要素を保持することを強調したかったためです。

:::message
`Number`の部分型でなくとも、加法っぽい可換な二項演算に対しては`Base.:+`にメソッドを追加して良い。
:::

### 型の昇格 (type promotion)
型の異なる足し算については、type promotionの仕組みによって同じ型に揃えられてから足し算が実行されます。
上記の例では、`k1`が`KnotVector{Float64}`に変換されてから足し算が実行されます。

BasicBSplineでは以下のように`promote_rule`にメソッドを追加することで[明示的に型変換を定義しています](https://github.com/hyrodium/BasicBSpline.jl/blob/v0.8.3/src/_KnotVector.jl#L36-L38)。[^promotion2]

```julia
function Base.promote_rule(::Type{KnotVector{T}}, ::Type{KnotVector{S}}) where {T,S}
    KnotVector{promote_type(T,S)}
end
```

[^promotion2]: このpromotionの仕組みの便利なところは、型Aと型Bの昇格のルールを決めるだけで、AとBを使ったメソッドすべてに型変換が利用できることにあります。
例えば、`A`と`B`が両方とも`Real`の部分型であれば、`+(::A, ::B)`, `-(::A, ::B)`, `*(::A, ::B)`, `/(::A, ::B)`などのすべてに定義が使えます。

:::message
Juliaの型の昇格は暗黙の型変換に近いですが、暗黙さが低いです。型変換が言語にハードコーディングされている訳ではなく、ユーザーが自由に設定することができます。
:::

## B-spline空間 (区分多項式空間)
ノット列を区分点に持つ$p$次区分多項式全体の空間を$p$次B-spline空間と呼びます。[^bspspace]
この空間は線形空間で、空間の次元や空間どうしの包含関係などが定義できます。

[^bspspace]: 独自用語です。広く普及している名称では無いことに注意してください。B-spline基底関数が基底になっています。

### 多項式次数と型パラメータ
BasicBSplineでは、B-spline空間を表す抽象型として`AbstractBSplineSpace{p}`が用意されています。
ここで`p`は多項式次数を表す型パラメータで、構造体のフィールドに含まれる実装にはなっていません。
このような型パラメータを使った理由は以下になります。

* ほとんどの場合で多項式次数は実行時に決定できる。よって型パラメータを使って問題ない。
* 後述の生成関数(`@generated`)を使うことで高速な実装が実現できる。

:::message
`struct`のフィールドにするか型パラメータにするかは

* 型パラメータにした際に速度向上が望めるか
* 実行時に型安定性を望めるか

を基準に考えれば良い。
:::

### 生成関数を使った基底関数の実装
BasicBSplineには、基底関数の値を計算するための関数として`bsplinebasis`と`bsplinebasisall`の2種類が用意されています。

* `bsplinebasis(P, i, t)`: `i`番目の基底関数の`t`での値。
    * Cox-de-Boorに基づく最も素朴な実装
    * 実験に使う際に便利
* `bsplinebasisall(P::BSplineSpace{p}, j, t)`: `j`番目の区間で非ゼロになっている基底関数の`t`での値たち。
    * 戻り値の型は`SVector{p+1}`
    * 効率的な実装のためには`bsplinebasis`よりも`bsplinebasisall`の方が良い

「絵」

これらの関数を実装するために、生成関数(`@generated`)が使われています。



:::message
Juliaでは、生成関数によって型パラメータごとに最適化されたコードを生成することができる。
:::

### プロット
BasicSplineでは、B-spline空間をプロットすることができます。

```julia
using BasicBSpline
using Plots

k = KnotVector([0.0, 0.5, 1.5, 2.5, 3.5, 5.5, 8.0, 9.0, 9.5, 10.0])
P = BSplineSpace{3}(k)
plot(P, ylims=(0,1))
```

空間をプロットすると言うと分かりにくいですが、有限次元の関数空間なのでその基底関数すべてをプロットすれば空間の可視化になっています。

このようなプロットの実装は、`RecipesBase`の`@recipe`マクロを使えば実装が可能です。
BasicBSpline.jlでの実装例は[こちら](https://github.com/hyrodium/BasicBSpline.jl/blob/v0.8.3/src/_PlotRecipes.jl#L1-L16)を参照してください。

:::message
独自に定義した型の標準的なプロットを追加するには、`RecipesBase.@recipe`でプロットを定義できる
:::

### 微分の実装

:::message
微分のためのインターフェースを用意するのは良い。これは後述の自動微分のルールの実装にも役立つ。
:::

### 包含関係
メソッドの追加の話


:::message
コレクションでなくとも、`Base.issubset`にメソッドを追加しても良い。
:::

:::message
Unicode文字による数学表記が便利！
:::

## B-spline多様体

### 型の実装

:::message
型パラメータは省略可能なので、重要度の高いものから並べるのが良い
:::

### 写像の計算

:::message
function-like objectの記法を使えば、インスタンスを写像のように扱えて便利
:::

## ChainRulesへの対応

:::message
`ChainRulesCore.frule`と`ChainRulesCore.rrule`へメソッドを追加するだけで
:::


# Q&A
## いつv1.0を出すんですか？
2023年には出せそうな雰囲気です。
予定としては以下の順で取り組む予定です。

* 現在検討している以下の破壊的変更に関する`warning`の追加
* 破壊的変更を加えてv0.9.0をリリース
* Julia Discourseにパッケージアナウンス
* 1ヶ月くらいフィードバックを待ってからv1.0.0をリリース

### `UniformBSplineSpace`の廃止
現在は
これを

### `fittingcontrolpoints`の移行
BasicBSplineの野望として、「JuliaにおけるB-splineのスタンダードになる」があります！

これを実現するためにはパッケージは軽量で、不要な依存先を減らす必要があります。
コード例で紹介した関数のフィッティングでは内部的にGauss求積を使っており、このために`FastGaussQuadrature.jl`に依存して
しまっています。
関数フィッティングは便利ですがB-splineに必須ではないので、`fittingcontolpoints`関数を別のBasicBSplineFitting.jlパッケージに移行することを検討しています。

## 他のパッケージよりも優れてるんですか？
なにも分からない…。
