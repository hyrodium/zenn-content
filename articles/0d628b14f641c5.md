---
title: "Juliaの中置演算子の扱い"
emoji: "🍡"
type: "tech"
topics:
  - "julia"
published: false
---

# はじめに

JuliaのJITコンパイルや多重ディスパッチ、実行速度については周知のところだと思います。

https://twitter.com/bicycle1885/status/503513042554855424

https://twitter.com/bicycle1885/status/1293180133667303431

本記事で書きたいことは**数学記号との相性の良さ**、特に**中置演算子**の性質です。
Julia言語は科学技術計算向けの言語として開発された背景があり、とくにUnicodeを使った数学記法との相性が良いように実装されています。

```julia
julia> α₄ = 42  # \alpha<Tab>\_4<Tab> で入力
42

julia> 3α₄/12π  # 3 * 42 / (12 * π)
3.3422538049298023

julia> 8 ∈ [1,8,12]  # 要素が入っているか。Unicodeの中置演算子(\in<Tab>)が便利！
true

julia> [2,4] ⊆ [1,8,12]  # 部分集合の判定。Unicodeの中置演算子(\subseteq<Tab>)が便利！
false
```

# 中置演算子に使用可能な記号
Juliaでは中置演算子に使用できる記号が決まっています。
以下の例を見てみましょう。
```julia
julia> 2 + 5  # ふつうのたしざん
7

julia> f = +
+ (generic function with 206 methods)

julia> 2 f 5  # 記号fは中置演算子として使えない。
ERROR: syntax: extra token "f" after end of expression

julia> 1 ± 4  # 記号±は中置演算子として使えるが、ここでは未定義なのでエラー。
ERROR: UndefVarError: ± not defined
```

では、中置演算子に使える記号の一覧は何でしょうか？

正解は
```
= += -= −= *= /= //= |\\=| ^= ÷= %= <<= >>= >>>= |\|=| &= ⊻= ≔ ⩴ ≕
~
:= $=
=>
?
← → ↔ ↚ ↛ ↞ ↠ ↢ ↣ ↦ ↤ ↮ ⇎ ⇍ ⇏ ⇐ ⇒ ⇔ ⇴ ⇶ ⇷ ⇸ ⇹ ⇺ ⇻ ⇼ ⇽ ⇾ ⇿ ⟵ ⟶ ⟷ ⟹ ⟺ ⟻ ⟼ ⟽ ⟾ ⟿ ⤀ ⤁ ⤂ ⤃ ⤄ ⤅ ⤆ ⤇ ⤌ ⤍ ⤎ ⤏ ⤐ ⤑ ⤔ ⤕ ⤖ ⤗ ⤘ ⤝ ⤞ ⤟ ⤠ ⥄ ⥅ ⥆ ⥇ ⥈ ⥊ ⥋ ⥎ ⥐ ⥒ ⥓ ⥖ ⥗ ⥚ ⥛ ⥞ ⥟ ⥢ ⥤ ⥦ ⥧ ⥨ ⥩ ⥪ ⥫ ⥬ ⥭ ⥰ ⧴ ⬱ ⬰ ⬲ ⬳ ⬴ ⬵ ⬶ ⬷ ⬸ ⬹ ⬺ ⬻ ⬼ ⬽ ⬾ ⬿ ⭀ ⭁ ⭂ ⭃ ⭄ ⭇ ⭈ ⭉ ⭊ ⭋ ⭌ ￩ ￫ ⇜ ⇝ ↜ ↝ ↩ ↪ ↫ ↬ ↼ ↽ ⇀ ⇁ ⇄ ⇆ ⇇ ⇉ ⇋ ⇌ ⇚ ⇛ ⇠ ⇢ ↷ ↶ ↺ ↻ --> <-- <-->
||
&&
in isa
> < >= ≥ <= ≤ == === ≡ != ≠ !== ≢ ∈ ∉ ∋ ∌ ⊆ ⊈ ⊂ ⊄ ⊊ ∝ ∊ ∍ ∥ ∦ ∷ ∺ ∻ ∽ ∾ ≁ ≃ ≂ ≄ ≅ ≆ ≇ ≈ ≉ ≊ ≋ ≌ ≍ ≎ ≐ ≑ ≒ ≓ ≖ ≗ ≘ ≙ ≚ ≛ ≜ ≝ ≞ ≟ ≣ ≦ ≧ ≨ ≩ ≪ ≫ ≬ ≭ ≮ ≯ ≰ ≱ ≲ ≳ ≴ ≵ ≶ ≷ ≸ ≹ ≺ ≻ ≼ ≽ ≾ ≿ ⊀ ⊁ ⊃ ⊅ ⊇ ⊉ ⊋ ⊏ ⊐ ⊑ ⊒ ⊜ ⊩ ⊬ ⊮ ⊰ ⊱ ⊲ ⊳ ⊴ ⊵ ⊶ ⊷ ⋍ ⋐ ⋑ ⋕ ⋖ ⋗ ⋘ ⋙ ⋚ ⋛ ⋜ ⋝ ⋞ ⋟ ⋠ ⋡ ⋢ ⋣ ⋤ ⋥ ⋦ ⋧ ⋨ ⋩ ⋪ ⋫ ⋬ ⋭ ⋲ ⋳ ⋴ ⋵ ⋶ ⋷ ⋸ ⋹ ⋺ ⋻ ⋼ ⋽ ⋾ ⋿ ⟈ ⟉ ⟒ ⦷ ⧀ ⧁ ⧡ ⧣ ⧤ ⧥ ⩦ ⩧ ⩪ ⩫ ⩬ ⩭ ⩮ ⩯ ⩰ ⩱ ⩲ ⩳ ⩵ ⩶ ⩷ ⩸ ⩹ ⩺ ⩻ ⩼ ⩽ ⩾ ⩿ ⪀ ⪁ ⪂ ⪃ ⪄ ⪅ ⪆ ⪇ ⪈ ⪉ ⪊ ⪋ ⪌ ⪍ ⪎ ⪏ ⪐ ⪑ ⪒ ⪓ ⪔ ⪕ ⪖ ⪗ ⪘ ⪙ ⪚ ⪛ ⪜ ⪝ ⪞ ⪟ ⪠ ⪡ ⪢ ⪣ ⪤ ⪥ ⪦ ⪧ ⪨ ⪩ ⪪ ⪫ ⪬ ⪭ ⪮ ⪯ ⪰ ⪱ ⪲ ⪳ ⪴ ⪵ ⪶ ⪷ ⪸ ⪹ ⪺ ⪻ ⪼ ⪽ ⪾ ⪿ ⫀ ⫁ ⫂ ⫃ ⫄ ⫅ ⫆ ⫇ ⫈ ⫉ ⫊ ⫋ ⫌ ⫍ ⫎ ⫏ ⫐ ⫑ ⫒ ⫓ ⫔ ⫕ ⫖ ⫗ ⫘ ⫙ ⫷ ⫸ ⫹ ⫺ ⊢ ⊣ ⟂ ⫪ ⫫ <: >:
<|
|>
: .. … ⁝ ⋮ ⋱ ⋰ ⋯
$
+ - − ¦ |\|| ⊕ ⊖ ⊞ ⊟ |++| ∪ ∨ ⊔ ± ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣
* / ⌿ ÷ % & · · ⋅ ∘ × |\\| ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ ∗ ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗ ⨟
//
<< >> >>>
^ ↑ ↓ ⇵ ⟰ ⟱ ⤈ ⤉ ⤊ ⤋ ⤒ ⤓ ⥉ ⥌ ⥍ ⥏ ⥑ ⥔ ⥕ ⥘ ⥙ ⥜ ⥝ ⥠ ⥡ ⥣ ⥥ ⥮ ⥯ ￪ ￬
```
です！[^julia-parser]

[^julia-parser]: この一覧は[src/julia-parser.scm](https://github.com/JuliaLang/julia/blob/v1.8.5/src/julia-parser.scm)から取得しました。[Discordの関連スレッド](https://discourse.julialang.org/t/list-of-binary-infix-operators/32282)

# 中置演算子は普通の関数のようにも使える
つまり、中置しなくてもOKです
```julia
julia> +(1,2)
3

julia> in(1,[1,2])
true

julia> ⊆([1,42],[1,2])
false
```

# 特殊な中置演算子`^`
```julia
julia> ^(3, 2)  # 3の2乗は9
9

julia> ^(3, -1)  # 3の2乗は1/3。しかし型安定ではない3の2乗は93の2乗は9
0.3333333333333333

julia> ^(3, 1-2)  # ^(3, -1)とは異なる！
ERROR: DomainError with -1:
Cannot raise an integer x to a negative power -1.
Make x or -1 a float by adding a zero decimal (e.g., 2.0^-1 or 2^-1.0 instead of 2^-1)or write 1/x^1, float(x)^-1, x^float(-1) or (x//1)^-1.
```

`literal_pow`に

[IrrationalConstantsRules.jl](https://github.com/hyrodium/IrrationalConstantRules.jl)

# 中置演算子を自分で定義する
```julia
julia> a ± b = (a+b, a-b)  # 左辺が中置演算子でもOK
± (generic function with 1 method)

julia> 1 ± 5  # 実行例
(6, -4)

julia> a::Int ± b::Int = (a+b, a-b, "Int")  # 型の指定があってもOK
± (generic function with 2 methods)

julia> ±(a::Float64, b::Float64) = (a+b, a-b, "Float64")  # 普通の関数と同じ書き方の方が可読性は高いですね
± (generic function with 3 methods)

julia> 1 ± 5, 1. ± 5.  # 実行例
((6, -4, "Int"), (6.0, -4.0, "Float64"))

julia> methods(±)  # メソッド一覧の取得
# 3 methods for generic function "±":
[1] ±(a::Int64, b::Int64) in Main at REPL[3]:1
[2] ±(a::Float64, b::Float64) in Main at REPL[4]:1
[3] ±(a, b) in Main at REPL[1]:1
```

ところで

```julia
julia> struct Point2
           x::Float64
           y::Float64
       end

julia> a::Point2 Base.:+ b::Point2 = Point2(a.x+b.x, a.y+b.y)
ERROR: syntax: extra token "Base" after end of expression
Stacktrace:
 [1] top-level scope
   @ none:1

julia> Base.:+(a::Point2, b::Point2) = Point2(a.x+b.x, a.y+b.y)

julia> Point2(1.0, 2.0) + Point2(8.0, -5.0)
Point2(9.0, -3.0)
```

# 中置演算子を自分でもっと定義する
高々..個しか使えないのは悲しいですよね。
もっと中置演算したい！
julia_opsuffs.hを参照すべし

# 複数の中置演算子
かなりトリッキーな例ですが、こんなことも可能です。
```julia
julia> Base.:+(a::Point2, b::Point2, c::Point2) = 42

julia> Point2(1,2) + Point2(3,4) + Point2(5,6)
42

julia> (Point2(1,2) + Point2(3,4)) + Point2(5,6)
Point2(9.0, 12.0)

julia> Point2(1,2) + (Point2(3,4) + Point2(5,6))
Point2(9.0, 12.0)
```

# 中置演算子の分類
`a == b < c`は`(a==b) & (b<c)`に等しくあって欲しいですが、`a * b / c`は`(a * b) / c`に等しくあって欲しいですよね。
その意味で、中置演算子には記号自体に意味が込められています。
`==`と同様のものには..
prec-comparisonはboolを返すべき

# 中置演算子の優先順位

prec-plusよりもprec-timesが強い！
優先順位は何で決まっているか？


# まとめ
Juliaでは中置演算子に使える記号があらかじめ決められている
中置演算子を装飾して新しい文字が使える
中置演算子にも色々な種類があり、優先順位や戻り値の定義がなされている
InfixOperatorHelper.jlを使えば便利！
