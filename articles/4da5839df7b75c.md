---
title: "Juliaでの等号と不等号いろいろ"
emoji: "🟰"
type: "tech"
topics:
  - "julia"
  - "math"
published: false
---

# TL;DR
- `isequal`は`==`とも`===`とも違うので注意
- `isless`は`<`とも`≤`とも違うので注意
- 一方で`isapprox`は`≈`と同じである

# 等号評価
Juliaには等号評価の演算として以下の4つの関数が用意されています。

* `==`
* `===`
* `isequal`
* `isapprox` (`≈`)

これらの差異は以下のコードを実行して確認することができます。

```julia
julia> operators = [isapprox, ==, isequal, ===]
4-element Vector{Function}:
 isapprox (generic function with 9 methods)
 == (generic function with 178 methods)
 isequal (generic function with 26 methods)
 === (built-in function)

julia> pairs = [(Inf, Inf), (Inf, Inf32), (1,1.0), (+0.0,-0.0), (1,nextfloat(1.0)), (NaN, NaN), (NaN, -NaN), (Inf, -Inf)]
8-element Vector{Tuple{Real, AbstractFloat}}:
 (Inf, Inf)
 (Inf, Inf32)
 (1, 1.0)
 (0.0, -0.0)
 (1, 1.0000000000000002)
 (NaN, NaN)
 (NaN, NaN)
 (Inf, -Inf)

julia> [f(pair...) for f in operators, pair in pairs]
4×8 Matrix{Bool}:
 1  1  1  1  1  0  0  0
 1  1  1  1  0  0  0  0
 1  1  1  0  0  1  1  0
 1  0  0  0  0  1  0  0
```

大雑把に言って`isapprox`, `==`, `isequal`, `===`の順で比較が厳格になっていきますが、`NaN`に関しては例外があるようです。
非自明な部分について以下に箇条書きで説明します。

* まず、`Inf`と`Inf`の比較はすべて等しいです。
  * `1/0`よりも`2/0`の方が大きい、なんてことはなくすべて等しくなります。
* 一方で`NaN == NaN`は`false`です。
  * IEEE754の規格でそう決められています。[^1]
* しかし`isequal(NaN, NaN)`は`true`です。
  * `isequal`は「オブジェクトが実質的に等しいか」を調べるもので、すべての`NaN`は等しく、`+0.0`と`-0.0`は異なります。
* `NaN === NaN`もまた`true`です。
  * `===`は「オブジェクトとして厳格に等しいか」を調べるもので、数学的性質とは無関係です。
* `-NaN`は`NaN`と表示されますが、これらは異なるものです。
  * これは`bitstring`で調べることができます

```julia
julia> bitstring(NaN)
"0111111111111000000000000000000000000000000000000000000000000000"

julia> bitstring(-NaN)
"1111111111111000000000000000000000000000000000000000000000000000"
```

[^1]: https://yosuke-furukawa.hatenablog.com/entry/2018/01/30/174425 などが詳しいです。

# 不等号評価
Juliaには不等号評価のような演算として以下の3つの関数が用意されています。

* `<`
* `<=` (`≤`)
* `isless`
