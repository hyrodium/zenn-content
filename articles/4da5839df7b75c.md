---
title: "Juliaでの等号と不等号いろいろ"
emoji: "🟰"
type: "tech"
topics:
  - "julia"
  - "math"
published: false
---

# TL;DR
- `isequal`は`==`とも`===`とも違うので注意
- `isless`は`<`とも`≤`とも違うので注意
- 一方で`isapprox`は`≈`と同じである

# 等号評価
## 実行例
Juliaには等号評価の演算として以下の4つの関数が用意されています。

* `==`
* `===`
* `isequal`
* `isapprox` (`≈`)

これらの差異は以下のコードを実行して確認することができます。

```julia
julia> operators = [isapprox, ==, isequal, ===]
4-element Vector{Function}:
 isapprox (generic function with 9 methods)
 == (generic function with 178 methods)
 isequal (generic function with 26 methods)
 === (built-in function)

julia> pairs = [(Inf, Inf), (Inf, Inf32), (1,1.0), (+0.0,-0.0), (1,nextfloat(1.0)), (NaN, NaN), (NaN, -NaN), (Inf, -Inf)]
8-element Vector{Tuple{Real, AbstractFloat}}:
 (Inf, Inf)
 (Inf, Inf32)
 (1, 1.0)
 (0.0, -0.0)
 (1, 1.0000000000000002)
 (NaN, NaN)
 (NaN, NaN)
 (Inf, -Inf)

julia> [f(pair...) for f in operators, pair in pairs]
4×8 Matrix{Bool}:
 1  1  1  1  1  0  0  0
 1  1  1  1  0  0  0  0
 1  1  1  0  0  1  1  0
 1  0  0  0  0  1  0  0
```

## 解説
大雑把に言って`isapprox`, `==`, `isequal`, `===`の順で比較が厳格になっていきますが、`NaN`に関しては例外があるようです。
非自明な部分について以下に箇条書きで説明します。

* まず、`Inf`と`Inf`の比較はすべて等しいです。
  * `1/0`よりも`2/0`の方が大きい、なんてことはなくすべて等しくなります。
* 一方で`NaN == NaN`は`false`です。
  * IEEE754の規格でそう決められています。[^1]
* しかし`isequal(NaN, NaN)`は`true`です。
  * `isequal`は「オブジェクトが実質的に等しいか」を調べるもので、すべての`NaN`は等しく、`+0.0`と`-0.0`は異なります。
* `NaN === NaN`もまた`true`です。
  * `===`は「オブジェクトとして厳格に等しいか」を調べるもので、数学的性質とは無関係です。
* `-NaN`は`NaN`と表示されますが、これらは異なるものです。
  * `NaN`の内部表現にバリエーションがあることが原因です。[^2][^3]
  * これは`bitstring`で調べることができます

```julia
julia> bitstring(NaN)
"0111111111111000000000000000000000000000000000000000000000000000"

julia> bitstring(-NaN)
"1111111111111000000000000000000000000000000000000000000000000000"
```

[^1]: https://yosuke-furukawa.hatenablog.com/entry/2018/01/30/174425 などが詳しいです。
[^2]: https://discourse.julialang.org/t/various-equalities-of-nan/42649 にDiscourseの議論があります。
[^3]: http://nmi.jp/2021-09-09-NaN などが詳しいです。

## 自分でメソッドを追加するには
新しい型を定義したときに

* `isequal`は`==`にフォールバックされる
* `==`は`===`にフォールバックされる
  * ところで、このデフォルトの実装は避けた方が良かったとされています。

という訳なので新しい型を`struct`で定義したときには

* 
* 

# 不等号評価
Juliaには不等号評価のような演算として以下の3つの関数が用意されています。

* `<`
* `<=` (`≤`)
* `isless`
